package com.example.web_honeypot.util;

import com.example.web_honeypot.model.AttackType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.*;
import org.springframework.web.client.RestTemplate;

import java.util.HashMap;
import java.util.Map;

@Slf4j
public class VulnerabilityTester {
    private final String baseUrl;
    private final RestTemplate restTemplate;
    private final Map<AttackType, TestResult> results;

    public VulnerabilityTester(String baseUrl) {
        this.baseUrl = baseUrl;
        this.restTemplate = new RestTemplate();
        this.results = new HashMap<>();
    }

    public void testAll() {
        testSqlInjection();
        testXss();
        testCommandInjection();
        testPathTraversal();
        testFileUpload();
        testCsrf();
        testSsrf();
        testXxe();
        testAuthBypass();
        testDeserialization();
        
        printResults();
    }

    private void testSqlInjection() {
        String payload = "admin' OR '1'='1";
        try {
            String url = baseUrl + "/vulnerable/query";
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            HttpEntity<String> request = new HttpEntity<>("username=" + payload, headers);
            ResponseEntity<String> response = restTemplate.postForEntity(url, request, String.class);
            
            boolean vulnerable = response.getBody() != null && response.getBody().contains("admin");
            results.put(AttackType.SQL_INJECTION, new TestResult(vulnerable, payload, response.getBody()));
        } catch (Exception e) {
            handleTestError(AttackType.SQL_INJECTION, payload, e);
        }
    }

    private void testXss() {
        String payload = "<script>alert('xss')</script>";
        try {
            String url = baseUrl + "/vulnerable/comment";
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            HttpEntity<String> request = new HttpEntity<>("comment=" + payload, headers);
            ResponseEntity<String> response = restTemplate.postForEntity(url, request, String.class);
            
            boolean vulnerable = response.getBody() != null && response.getBody().contains("<script>");
            results.put(AttackType.XSS, new TestResult(vulnerable, payload, response.getBody()));
        } catch (Exception e) {
            handleTestError(AttackType.XSS, payload, e);
        }
    }

    private void testCommandInjection() {
        String payload = "ls;cat /etc/passwd";
        try {
            String url = baseUrl + "/vulnerable/execute";
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            HttpEntity<String> request = new HttpEntity<>("command=" + payload, headers);
            ResponseEntity<String> response = restTemplate.postForEntity(url, request, String.class);
            
            boolean vulnerable = response.getStatusCode() == HttpStatus.OK;
            results.put(AttackType.COMMAND_INJECTION, new TestResult(vulnerable, payload, response.getBody()));
        } catch (Exception e) {
            handleTestError(AttackType.COMMAND_INJECTION, payload, e);
        }
    }

    private void testPathTraversal() {
        String payload = "../../../etc/passwd";
        try {
            String url = baseUrl + "/vulnerable/download?file=" + payload;
            ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
            
            boolean vulnerable = response.getStatusCode() == HttpStatus.OK;
            results.put(AttackType.PATH_TRAVERSAL, new TestResult(vulnerable, payload, response.getBody()));
        } catch (Exception e) {
            handleTestError(AttackType.PATH_TRAVERSAL, payload, e);
        }
    }

    private void testCsrf() {
        try {
            String url = baseUrl + "/vulnerable/transfer";
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            String payload = "to=attacker&amount=1000";
            HttpEntity<String> request = new HttpEntity<>(payload, headers);
            ResponseEntity<String> response = restTemplate.postForEntity(url, request, String.class);
            
            boolean vulnerable = response.getStatusCode() == HttpStatus.OK;
            results.put(AttackType.CSRF, new TestResult(vulnerable, payload, response.getBody()));
        } catch (Exception e) {
            handleTestError(AttackType.CSRF, "CSRF Attack", e);
        }
    }

    private void testSsrf() {
        String payload = "http://localhost:8080/internal/api";
        try {
            String url = baseUrl + "/vulnerable/fetch?url=" + payload;
            ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
            
            boolean vulnerable = response.getStatusCode() == HttpStatus.OK;
            results.put(AttackType.SSRF, new TestResult(vulnerable, payload, response.getBody()));
        } catch (Exception e) {
            handleTestError(AttackType.SSRF, payload, e);
        }
    }

    private void testXxe() {
        String payload = "<?xml version=\"1.0\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><foo>&xxe;</foo>";
        try {
            String url = baseUrl + "/vulnerable/parse-xml";
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_XML);

            HttpEntity<String> request = new HttpEntity<>(payload, headers);
            ResponseEntity<String> response = restTemplate.postForEntity(url, request, String.class);
            
            boolean vulnerable = response.getStatusCode() == HttpStatus.OK;
            results.put(AttackType.XXE, new TestResult(vulnerable, payload, response.getBody()));
        } catch (Exception e) {
            handleTestError(AttackType.XXE, payload, e);
        }
    }

    private void testAuthBypass() {
        try {
            String url = baseUrl + "/vulnerable/admin/data";
            HttpHeaders headers = new HttpHeaders();
            headers.set("Role", "admin");

            HttpEntity<String> request = new HttpEntity<>(null, headers);
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, request, String.class);
            
            boolean vulnerable = "Sensitive data accessed".equals(response.getBody());
            results.put(AttackType.AUTH_BYPASS, new TestResult(vulnerable, "Role=admin", response.getBody()));
        } catch (Exception e) {
            handleTestError(AttackType.AUTH_BYPASS, "Auth Bypass", e);
        }
    }

    private void testFileUpload() {
        // 文件上传测试需要特殊处理，这里只是示例
        results.put(AttackType.FILE_UPLOAD, new TestResult(true, "shell.jsp", "需要手动测试"));
    }

    private void testDeserialization() {
        // 反序列化测试需要特殊处理，这里只是示例
        results.put(AttackType.DESERIALIZATION, new TestResult(true, "序列化对象", "需要手动测试"));
    }

    private void printResults() {
        log.info("漏洞测试结果汇总：");
        log.info("----------------------------------------");
        results.forEach((type, result) -> {
            log.info("漏洞类型: {}", type);
            log.info("是否存在: {}", result.isVulnerable() ? "是" : "否");
            log.info("测试载荷: {}", result.getPayload());
            log.info("测试结果: {}", result.getResponse());
            log.info("----------------------------------------");
        });
    }

    private void handleTestError(AttackType type, String payload, Exception e) {
        log.error("测试失败 - {}: {}", type, e.getMessage());
        results.put(type, new TestResult(false, payload, "测试失败: " + e.getMessage()));
    }

    @lombok.Data
    @lombok.AllArgsConstructor
    private static class TestResult {
        private boolean vulnerable;
        private String payload;
        private String response;
    }

    public static void main(String[] args) {
        VulnerabilityTester tester = new VulnerabilityTester("http://localhost:9999");
        tester.testAll();
    }
} 